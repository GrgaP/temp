/******************************************************************************/
/* This file has been generated by the uGFX-Studio                            */
/*                                                                            */
/* http://ugfx.org                                                            */
/******************************************************************************/

#include "user_colors.h"
#include "user_styles.h"
#include "gui.h"
#include "main.h"
//#include "i2c_drv.h"
#include "sht20_module.h"
#include "gfx.h"

#include "../../../../src/ginput/ginput_driver_mouse.h"

osThreadId GUI_mainTaskHandle;//

int16_t temp_val;
int16_t hmdt_val;

// GListeners
GListener gl;

GTimer RefreshTimerId;

// GHandles
//GHandle ghLabel1, ghLabel2;
//GHandle ghList1, ghList2;
GHandle ghButton1, ghButton2;

// Fonts
font_t dejavu_sans_20_anti_aliased;

// Images
gdispImage ugfx_150x50_282828;

#define N 1024				/* Number of dots */
#define SCALE 8192
#define INCREMENT 512		/* INCREMENT = SCALE / sqrt(N) * 2 */
#define PI2 6.283185307179586476925286766559

#define background Black

uint16_t width, height;
int16_t sine[SCALE+(SCALE/4)];
int16_t *cosi = &sine[SCALE/4]; /* cos(x) = sin(x+90d)... */
int16_t angleX = SCALE/8, angleY = 3*SCALE/1, angleZ = 3*SCALE/4;
int16_t speedX = 1, speedY = 3, speedZ = 2;
int16_t xyz[3][N];
color_t col[N];

//uint8_t batt_val;

static void createWidgets(void)
{
	GWidgetInit wi;

	// Apply some default values for GWIN
	gwinWidgetClearInit(&wi);
	wi.g.show = TRUE;

	/*// Create the label for the first list
	wi.g.width = 150; wi.g.height = 20; wi.g.x = 10, wi.g.y = 10;
	wi.text = "List 1: Default";
	ghLabel1 = gwinLabelCreate(0, &wi);

	// Create the label for the second list
	wi.g.width = 150; wi.g.height = 20; wi.g.x = 10, wi.g.y = 170;
	wi.text = "List 2: Smooth";
	ghLabel1 = gwinLabelCreate(0, &wi);

	// The first list widget
	wi.g.width = 150;
	wi.g.height = 110;
	wi.g.y = 35;
	wi.g.x = 10;
	wi.text = "Name of list 1";
	ghList1 = gwinListCreate(0, &wi, FALSE);
        //gwinListSetScroll(ghList1, scrollSmooth);

	// The second list widget
	wi.g.width = 150;
	wi.g.height = 110;
	wi.g.y = 195;
	wi.g.x = 10;
	wi.text = "Name of list 2";
	ghList2 = gwinListCreate(0, &wi, FALSE);
	gwinListSetScroll(ghList2, scrollSmooth);*/
        
        wi.g.width = 100;
        wi.g.height = 50;
        wi.g.x = 70;
        wi.g.y = 25;
        wi.text = "Set Data & Time";
        
        ghButton1 = gwinButtonCreate(NULL, &wi);
        
        wi.g.y = 95;
        wi.text = "Touch calibrate";
        
        ghButton2 = gwinButtonCreate(NULL, &wi);
}

static void TnD_print(void)
{
  static char TimeStr_buffer[8];
  static char DateStr_buffer[8];
    
    //HAL_GPIO_WritePin(GPIOF, GPIO_PIN_7, !(HAL_GPIO_ReadPin(GPIOF,GPIO_PIN_7)));    

    //HAL_GPIO_WritePin(GPIOF, GPIO_PIN_7, 1);
        
    //gdispGFillArea(GDISP, 10, 10, 200, 30, BLACK);
    //sprintf(TimeStr_buffer, "%x", RTC->TR);
    DIMS_RTC_module_getStrT(TimeStr_buffer);
    //gdispFillArea(50, 45, 140, 30, BLACK);
    gdispDrawStringBox(50, 10, 140, 100, TimeStr_buffer, gdispOpenFont("DejaVuSans24_aa"), WHITE, 0);
    
    DIMS_RTC_module_getStrD(DateStr_buffer);
    //gdispFillArea(50, 155, 140, 30, BLACK);
    gdispDrawStringBox(50, 120, 140, 100, DateStr_buffer, gdispOpenFont("DejaVuSans24_aa"), WHITE, 0);
    
    //HAL_GPIO_WritePin(GPIOF, GPIO_PIN_7, 0);
}

static void SHT20_test_indicate(void)
{
  static char out_str1[4];
  static char out_str2[4];

  sprintf(out_str1, "%03d", temp_val);
  sprintf(out_str2, "%03d", hmdt_val);
  
  gdispDrawStringBox(120, 10, 70, 30, out_str1, gdispOpenFont("DejaVuSans24_aa"), WHITE, 0);  
  gdispDrawStringBox(120, 40, 70, 60, out_str2, gdispOpenFont("DejaVuSans24_aa"), WHITE, 0);    
}
/*
static void temp_indicate(void)
{
  static char out_str[10];
  
  //GEventMouse state;
  
  static uint8_t t,h;

  GMouse *m;
  // Find the instance
  if (!(m = (GMouse *)gdriverGetInstance(GDRIVER_TYPE_MOUSE, 0)))
    return;
  
  x = m->clickpos.x;
  y = m->clickpos.y;
  
  //ginputGetMouseStatus( (uint16_t)m , state);
  

  sprintf(out_str, "%03d;%03d", x, y);

  gdispDrawStringBox(10, 10, 140, 30, out_str, gdispOpenFont("DejaVuSans24_aa"), WHITE, 0);
    
}
*/
static void Refresh_Timer_cb(void *param)
{
    
  //uint8_t tmp_var;
  
  //HAL_GPIO_WritePin(GPIOF, GPIO_PIN_9, !(HAL_GPIO_ReadPin(GPIOF,GPIO_PIN_9)));      
  
  //tmp_var = I2Cx_Read(0x10, 0x55);  
  
  temp_val = sht20readTemp();
  hmdt_val = sht20readRh();
};

static void initialize(void)
{
	uint16_t i;

	/* if you change the SCALE*1.25 back to SCALE, the program will
	 * occassionally overrun the cosi array -- however this actually
	 * produces some interesting effects as the BUBBLES LOSE CONTROL!!!!
	 */
	for (i = 0; i < SCALE+(SCALE/4); i++) {
		//sine[i] = (-SCALE/2) + (int)(sinf(PI2 * i / SCALE) * sinf(PI2 * i / SCALE) * SCALE);
		sine[i] = (int)(sinf(PI2 * i / SCALE) * SCALE*0.8);
	}
}

static void matrix(int16_t xyz[3][N], color_t col[N])
{
	static uint32_t t = 0;
	int16_t x = -SCALE, y = -SCALE;
	uint16_t i, s, d;
	uint8_t red, grn, blu;

#define RED_COLORS (32)
#define GREEN_COLORS (64)
#define BLUE_COLORS (32)

	for (i = 0; i < N; i++) {
		xyz[0][i] = x;
		xyz[1][i] = y;

		d = sqrt(x * x + y * y);	/* originally a fastsqrt() call */
		s = sine[(t * 30) % SCALE] + SCALE;

		xyz[2][i] = sine[(d + s) % SCALE] * sine[(t * 10) % (SCALE/2)] / SCALE / 2;

		red = (cosi[xyz[2][i] + SCALE / 2] + SCALE) * (RED_COLORS - 1) / SCALE / 2;
		grn = (cosi[(xyz[2][i] + SCALE / 2 + 2 * SCALE / 3) % SCALE] + SCALE) * (GREEN_COLORS - 1) / SCALE / 2;
		blu = (cosi[(xyz[2][i] + SCALE / 2 + SCALE / 3) % SCALE] + SCALE) * (BLUE_COLORS - 1) / SCALE / 2;
		col[i] = ((red << 11) + (grn << 5) + blu);

		x += INCREMENT;

		if (x >= SCALE) {
			x = -SCALE;
			y += INCREMENT;
		}
	}
  
	t++;
}

static void rotate(int16_t xyz[3][N], uint16_t angleX, uint16_t angleY, uint16_t angleZ)
{
	uint16_t i;
	int16_t tmpX, tmpY;
	int16_t sinx = sine[angleX], cosx = cosi[angleX];
	int16_t siny = sine[angleY], cosy = cosi[angleY];
	int16_t sinz = sine[angleZ], cosz = cosi[angleZ];

	for (i = 0; i < N; i++) {
		tmpX      = (xyz[0][i] * cosx - xyz[2][i] * sinx) / SCALE;
		xyz[2][i] = (xyz[0][i] * sinx + xyz[2][i] * cosx) / SCALE;
		xyz[0][i] = tmpX;

		tmpY      = (xyz[1][i] * cosy - xyz[2][i] * siny) / SCALE;
		xyz[2][i] = (xyz[1][i] * siny + xyz[2][i] * cosy) / SCALE;
		xyz[1][i] = tmpY;

		tmpX      = (xyz[0][i] * cosz - xyz[1][i] * sinz) / SCALE;
		xyz[1][i] = (xyz[0][i] * sinz + xyz[1][i] * cosz) / SCALE;
		xyz[0][i] = tmpX;
	}
}

static void draw(int16_t xyz[3][N], color_t col[N])
{
	static uint16_t oldProjX[N] = {0};
	static uint16_t oldProjY[N] = {0};
	static uint8_t oldDotSize[N] = {0};
	uint16_t i, projX, projY, projZ, dotSize;

	for (i = 0; i < N; i++) {
		projZ = SCALE - (xyz[2][i] + SCALE) / 4;
		projX = width / 2 + (xyz[0][i] * projZ / SCALE) / 25;
		projY = height / 2 + (xyz[1][i] * projZ / SCALE) / 25;
		dotSize = 3 - (xyz[2][i] + SCALE) * 2 / SCALE;

		gdispDrawCircle(oldProjX[i], oldProjY[i], oldDotSize[i], background);

		if (projX > dotSize && projY > dotSize && projX < width - dotSize && projY < height - dotSize) {
			gdispDrawCircle(projX, projY, dotSize, col[i]);
			oldProjX[i] = projX;
			oldProjY[i] = projY;
			oldDotSize[i] = dotSize;
		}
	}
}
    
static void guiCreate(void)
{
 /* // Set the widget defaults
  gwinSetDefaultFont(gdispOpenFont("DejaVuSans24_aa"));
  gwinSetDefaultStyle(&WhiteWidgetStyle, FALSE);
  gdispClear(Black);
  
  //createWidgets();
  
  // We want to listen for widget events
  geventListenerInit(&gl);
  gwinAttachListener(&gl);*/
  
  
  gtimerInit(&RefreshTimerId); 
  
  
  
  gtimerStart( &RefreshTimerId, Refresh_Timer_cb, 0, TRUE, 1000);  
  
  
/*
  // Add some items to the first list widget
  gwinListAddItem(ghList1, "Item 0", FALSE);
  gwinListAddItem(ghList1, "Item 1", FALSE);
  gwinListAddItem(ghList1, "Item 2", FALSE);
  gwinListAddItem(ghList1, "Item 3", FALSE);
  gwinListAddItem(ghList1, "Item 4", FALSE);
  gwinListAddItem(ghList1, "Item 5", FALSE);
  gwinListAddItem(ghList1, "Item 6", FALSE);
  gwinListAddItem(ghList1, "Item 7", FALSE);
  gwinListAddItem(ghList1, "Item 8", FALSE);
  gwinListAddItem(ghList1, "Item 9", FALSE);
  gwinListAddItem(ghList1, "Item 10", FALSE);
  gwinListAddItem(ghList1, "Item 11", FALSE);
  gwinListAddItem(ghList1, "Item 12", FALSE);
  gwinListAddItem(ghList1, "Item 13", FALSE);

  // Add some items to the second list widget
  // This time we will disable the render until
  // all the items have been added
  gwinListEnableRender(ghList2, FALSE);
  gwinListAddItem(ghList2, "Item 0", FALSE);
  gwinListAddItem(ghList2, "Item 1", FALSE);
  gwinListAddItem(ghList2, "Item 2", FALSE);
  gwinListAddItem(ghList2, "Item 3", FALSE);
  gwinListAddItem(ghList2, "Item 4", FALSE);
  gwinListAddItem(ghList2, "Item 5", FALSE);
  gwinListAddItem(ghList2, "Item 6", FALSE);
  gwinListAddItem(ghList2, "Item 7", FALSE);
  gwinListAddItem(ghList2, "Item 8", FALSE);
  gwinListAddItem(ghList2, "Item 9", FALSE);
  gwinListAddItem(ghList2, "Item 10", FALSE);
  gwinListAddItem(ghList2, "Item 11", FALSE);
  gwinListAddItem(ghList2, "Item 12", FALSE);
  gwinListAddItem(ghList2, "Item 13", FALSE);

  gwinListEnableRender(ghList2, TRUE);  */
  
      
  //gdispClear(Grey);
    
  width = (uint16_t)gdispGetWidth();
  height = (uint16_t)gdispGetHeight();

  initialize();

}

void guiEventLoop(void)
{
	/*GEvent* pe;

	while (1) {
		// Get an event
		pe = geventEventWait(&gl, TIME_INFINITE);
		switch (pe->type) {
                case GEVENT_GWIN_BUTTON:
                    if(((GEventGWinButton*)pe)->gwin == ghButton1)
                    {
                      HAL_GPIO_WritePin(GPIOF, GPIO_PIN_7, !(HAL_GPIO_ReadPin(GPIOF,GPIO_PIN_7)));
                    };
                    if(((GEventGWinButton*)pe)->gwin == ghButton2)
                    {
                      HAL_GPIO_WritePin(GPIOF, GPIO_PIN_8, !(HAL_GPIO_ReadPin(GPIOF,GPIO_PIN_8)));
                    };
                  break;
                default:
                  break;
		}

	}*/
  
    int pass = 0;
  
                matrix(xyz, col);
		rotate(xyz, angleX, angleY, angleZ);
		draw(xyz, col);
                
                TnD_print();
                
                SHT20_test_indicate();
               // touch_pos_indicate();

		angleX += speedX;
		angleY += speedY;
		angleZ += speedZ;

		if (pass > 400) speedY = 1;
		if (pass > 800) speedX = 1;
		if (pass > 1200) speedZ = 1;
		pass++;

		if (angleX >= SCALE) angleX -= SCALE;
		else if (angleX < 0) angleX += SCALE;

		if (angleY >= SCALE) angleY -= SCALE;
		else if (angleY < 0) angleY += SCALE;

		if (angleZ >= SCALE) angleZ -= SCALE;
		else if (angleZ < 0) angleZ += SCALE;
	  
		//gfxSleepMilliseconds(4);	// The F7 is a bit too fast... Slow this down
}

void GUI_main_Task(void const * argument)
{
   gfxInit();
   
   sht20_reset();
  
   guiCreate();
  
   for(;;)
   {    
     gdispClear(Black);//Erasing a next free framebuffer    
     guiEventLoop();
     
     gdispFlush();

     vTaskDelay(4);
   }
}

void GUI_start(void)
{
  osThreadDef(GUI_mainTask, GUI_main_Task, osPriorityHigh, 0, 1024);
  GUI_mainTaskHandle = osThreadCreate(osThread(GUI_mainTask), NULL);
};
